;;;;;; File: MGC (Music Generator for Composing);;;;;; Author: David Cope <howell@ucsc.edu>;;; WWW Address: arts.ucsc.edu/faculty/cope;;; Organization: Workshop in Algorithmic Computer Music;;; Created: 2008/06/10 3:21:50 (UTC-8);;; Implementation: Common Lisp;;; Target: same;;; Purpose: simple testing software;;; Keywords: no;;; Requires: none;;; Resources: none;;; Dependencies: CL;;; References: Help file;;; Standards: ;;; Unit-Test: ;;; Limitations: ;;; To-Do: debug and enhance;;; Bugs: sure#| FIXES AND CONTRIBUTIONSPlease list your name, the date, and the fix or added code below.Please try to maintain chronological order (most recent at the top).cope/7.30.08/cleaned up problems associated with so many previous fixes.goodman/6.28.08/enhanced create-the-numbers so that it more properly leaves numbers alone when normalize variable set to nil.goodman/6.28.08/changed generate to tell save-as-midi to ignore *work-dir* since full path suppliedgoodman/6.26.08/added *work-dir* parameter to save-as-midi function.goodman/6.26.08/fixed generate voices to default number to have a list of numbers, i.e. '(50 50) instead of just '(50)cope/6.25.08/fixed bug on inputting floats for pitchesgoodman/6.25.08/set *work-dir* parameter to //Users/wacm/Documents/ for WACM computerscope/6.25.08/changed create-the-numbers to take un-normalized data.cope and goodman/6.24.08/added code to make pitches in order if first of pitches is not 'rgoodman/6.22.08/added *note-overlap* parameter added to generate and new remove-overlaps function.goodman/6.22.08/added *mgc-events* to generate.goodman/6.22.08/added *WORK-DIR* mods to generate for easier folder access.goodman/6.22.08/added *overwrite-if-exists* mod to create-midi-file overwrite files during testing.cope/6,15,08/changed *x* to x in create-numbers.|#;;;Global variables.(defParameter *WORK-DIR* "/Users/wacm/Documents/") ;;Set this to the default location you are working in.(defVar *RS* (make-random-state t) "Variable for storing the current random state.")(defVar *LOW-RANGE-ONTIMES* 125 "Smallest difference between ontimes allowed.")(defVar *HIGH-RANGE-ONTIMES* 3000 "Largest difference between ontimes allowed.")(defVar *MOD-ONTIMES* 1000 "Mod number used to reduce out of range ontimes.")(defVar *LOW-RANGE-PITCH* 36 "Smallest difference between pitches allowed.")(defVar *HIGH-RANGE-PITCH* 108 "Largest difference between pitches allowed.")(defVar *MOD-PITCHES* 12 "Mod number used to reduce out of range pitches.")(defVar *LOW-RANGE-DURATIONS* 125 "Smallest difference between durations allowed.")(defVar *HIGH-RANGE-DURATIONS* 3000 "Largest difference between durations allowed.")(defVar *MOD-DURATIONS* 1000 "Mod number used to reduce out of range durations.")(defVar *LOW-RANGE-CHANNELS* 1 "Smallest difference between channels allowed.")(defVar *HIGH-RANGE-CHANNELS* 17 "Largest difference between channels allowed.")(defVar *MOD-CHANNELS* 16 "Mod number used to reduce out of range channels.")(defVar *LOW-RANGE-DYNAMICS* 45 "Smallest difference between dynamics allowed.")(defVar *HIGH-RANGE-DYNAMICS* 127 "Largest difference between dynamics allowed.")(defVar *MOD-DYNAMICS* 128 "Mod number used to reduce out of range dynamics.")(defVar X 1 "The default value for x in the one-variable formulas used.")(defVar *MGC-Events* nil "Temporary storage of events")(defVar *note-overlap* nil);;;Main sequence#|(GENERATE :name "cope.mid")#P"cope¦.mid"|#(defun GENERATE (&key (name "test.midi")(number 25)(ontimes 'r)(pitches 'r)(durations 'r)(channels 'r)(dynamics 'r)(harmonies nil)(save t)(note-overlap *note-overlap*))   "Top-level function for generating MIDI files based on the combination ofd its arguments. Returns the pathname of the MIDI file created."  (when name (setq name (concatenate 'string *WORK-DIR* name))) ;;set and forget the working directory, then just specify a name  (if (and (listp pitches) (not (equal (first pitches) 'r))(not (member 'x (unlist pitches) :test #'equal))(not (zerop (first pitches))))      (setq number (length pitches)))  (if harmonies (let ((cope-events (make-harmonic-cope-events (create-the-numbers number ontimes *low-range-ontimes* *high-range-ontimes* *mod-ontimes* nil)                                                              (create-harmonies number (length (first harmonies)) harmonies)                                                              (create-the-numbers number durations *low-range-durations* *high-range-durations* *mod-durations* nil)                                                              (create-the-numbers number channels *low-range-channels* *high-range-channels* *mod-channels* nil)                                                              (create-the-numbers number dynamics *low-range-dynamics* *high-range-dynamics* *mod-dynamics* nil))))                  ;;doesn't work for harmonic yet ;(if (not note-overlap) (setq cope-events (remove-overlap cope-events)))                   (if (not (null name)) (save-as-midi (make-pathname :name name) (setq *mgc-events* cope-events) nil)                    cope-events))      (let ((cope-events (make-cope-events (create-the-numbers number ontimes *low-range-ontimes* *high-range-ontimes* *mod-ontimes* nil)                                           (create-the-numbers number pitches *low-range-pitch* *high-range-pitch* *mod-pitches*)                                           (create-the-numbers number durations *low-range-durations* *high-range-durations* *mod-durations* nil)                                           (create-the-numbers number channels *low-range-channels* *high-range-channels* *mod-channels* nil)                                           (create-the-numbers number dynamics *low-range-dynamics* *high-range-dynamics* *mod-dynamics* nil))))        (if (not note-overlap) (setq cope-events (remove-overlap cope-events)))        (if (and save name) (save-as-midi (make-pathname :name name) (setq *mgc-events* cope-events) nil)             cope-events))))#|(GENERATE-VOICES :name "cope.mid")#P"cope¦.mid"|#(defun GENERATE-VOICES (&key (name "test.midi")(numbers '(50 50))(ontimes '(r r))(pitches '(r r))(durations '(r r))(channels '(r r))(dynamics '(r r))(harmonies '(nil nil))(save t))  "Top-level function for generating MIDI files of multi-channel tests, where each channel can be controlled separately according to argument lists."  (setq name (concatenate 'string *WORK-DIR* name))  (if (and save name) (save-as-midi (make-pathname :name name) (multi-gen name numbers ontimes pitches durations channels dynamics harmonies) nil)      (multi-gen name numbers ontimes pitches durations channels dynamics harmonies)))#|(MULTI-GEN "copes.mid" '(50 50) '(R R) '(R R) '(R R) '(R R) '(R R) '(NIL NIL))((0 47 2726 4 96) (876 64 1355 9 45) (3830 103 2637 6 77) . . . .|#(defun MULTI-GEN (name numbers ontimes pitches durations channels dynamics harmonies)  "Recurse work horse for generate-voices."  (if (null numbers) ()      (append (generate :name nil :number (first numbers) :ontimes (first ontimes) :pitches (first pitches) :durations (first durations) :channels (first channels) :dynamics (first dynamics) :harmonies (first harmonies))              (multi-gen name (rest numbers)(rest ontimes)(rest pitches)(rest durations)(rest channels)(rest dynamics)(rest harmonies)))))#|(CREATE-THE-NUMBERS 50 125 125 3000 1000)(125 125 125 125 125 125 125 125 . . . .|#(defun CREATE-THE-NUMBERS (number numbers low high mod &optional (normalize t))  "Creates the numbers for each of the parameters for generate."   (cond ((numberp numbers) (make-list number :initial-element numbers))        ((equal numbers 'r)         (made-random-numbers number low high))        ((and (listp numbers)(numberp (first numbers))(zerop (first numbers)) normalize)         (run-numbers number (broadcast-throughout-range numbers low high mod)))        ((and (listp numbers)(numberp (first numbers))(or (rangep numbers) (not normalize))         numbers))        ((and (listp numbers)(equal (first numbers) 'r))         (run-numbers number (if normalize (normalize-numbers (rest numbers) low high) (rest numbers))))        ((and (listp numbers)(not (member 'x (unlist numbers) :test #'equal))(rangep numbers))         (eval numbers))        ((and (listp numbers)(member 'x (unlist numbers) :test #'equal))         (normalize-numbers (create-numbers number numbers mod) low high))	((not normalize) numbers)        (t (normalize-numbers (create-numbers number numbers mod) low high))))#|(CREATE-NUMBERS 50 '(/ 1 (SIN (* X X))) 12)(1.1883951057781212 1.0126961360539488 1.1695887813913146 1.0209345732286002 1.1579837395505137 1.0270145632320122 . . . .|#(defun CREATE-NUMBERS (number formula mod &optional (x x))  "Evaluates the formulas used."  (if (zerop number)()      (let ((new-number (eval (replace-x formula x))))        (cons new-number              (create-numbers (1- number) formula mod new-number)))))#|(REPLACE-X '(/ 1 (SIN (* X X))) 1.0653209466490454) (/ 1 (SIN (* 1.0653209466490454 1.0653209466490454)))|#(defun REPLACE-X (formula x)  "Double recursive function to replace x with a value."  (cond ((null formula)())        ((atom formula)         (if (equal formula 'x)           x formula))        (t (cons (replace-x (first formula) x)                 (replace-x (rest formula) x)))))#|(MADE-RANDOM-NUMBERS 50 45 127)(120 103 95 109 74 96 117 69 47 117 54 84 53 83 60 70 63 90 101 76 88 54 86 . . . .|#(defun MADE-RANDOM-NUMBERS (number low high)  "Creates pseudo-random numbers of size number."  (if (zerop number)()      (cons (+ low (random (- high low) *rs*))            (made-random-numbers (1- number) low high))))#|(RUN-NUMBERS 50 '(36 48 60 72 84 96 108 38 50 62 74 86 98 40 52 64 76 . . . .(36 56 102 86 78 56 56 46 80 94 80 104 96 54 66 46 100 68 102 40 88 78 . . . .|#(defun RUN-NUMBERS (number numbers)  "Chooses number amount of pseudo-random numbers from its second arg."  (if (zerop number)()      (cons (choose-one numbers)            (run-numbers (1- number) numbers))));;;Harmonies.#|(CREATE-HARMONIES 50 8 '((0 2 3 5 6 8 9 11)))((62 41 51 99 80 89 42 99) (39 47 99 83 44 65 83 59) . . . .|#(defun CREATE-HARMONIES (n texture sets)  "Creates harmonies of texture size following sets."  (if (zerop n) ()      (cons (select-numbers texture (create-harmony (choose-one sets)))            (create-harmonies (1- n) texture sets))))#|(CREATE-HARMONY '(0 2 3 5 6 8 9 11)) (36 48 60 72 84 96 108 38 50 62 74 86 98 39 51 63 75 87 . . . .|#(defun CREATE-HARMONY (set)  "Creates a harmony of texture size following set."  (if (null set) ()      (append (broadcast-throughout-range (list (first set)) *low-range-pitch* *high-range-pitch* 12)              (create-harmony (rest set)))))#|(SELECT-NUMBERS 8 '(36 48 60 72 84 96 108 38 50 62 74 86 98 39 51 63 75 87 99 41 . . . .(62 41 51 99 80 89 42 99)|#(defun SELECT-NUMBERS (n list)  "Pseudo-random selection of numbers based on list."  (if (zerop n) ()      (cons (choose-one list)            (select-numbers (1- n) list))))#|(MAKE-HARMONIC-COPE-EVENTS '(125 125 125 125 125 . . . .((0 47 419 16 96) (0 86 419 16 96) (0 102 419 16 96) (0 71 419 16 96) (0 90 419 16 96) . . . .|#(defun MAKE-HARMONIC-COPE-EVENTS (ontimes pitches durations channels dynamics &optional (ontime 0))  "Turn harmonies into simultaneous cope-events."  (cond ((not (all-equalp (list (length ontimes)(length durations)(length channels)(length dynamics))))         (let ((new-arguments (make-equal ontimes durations channels dynamics)))           (make-harmonic-cope-events (first new-arguments) pitches (second new-arguments)(third new-arguments)(fourth new-arguments))))        ((null ontimes)())        (t (append (loop for pitch in (choose-one pitches)                         collect (list ontime pitch (first durations)(first  channels)(first dynamics)))                   (make-harmonic-cope-events (rest ontimes) pitches (rest durations)(rest channels)(rest dynamics)(+ ontime (first ontimes)))))));;;Developing forms#|(GENERATE-FORMS "22.mid" '(()(nil 80 125 24 6000 12 80 ((0 4 7)))()))#P"22¦.mid"|#(defun GENERATE-FORMS (&key (name "test.mid") (forms nil) (cope-events ())(generate-voices ()))  "To distinguish extended forms and generate-voices."  (cond ((null forms) (progn (when name (setq name (concatenate 'string *WORK-DIR* name)))                             (save-as-midi (make-pathname :name name) cope-events nil)))        ((null generate-voices)(progn (setq cope-events (re-time (apply #'extend-forms (first forms)) cope-events))                                      (generate-forms :name name :forms (rest forms) :cope-events cope-events)))        (t (progn (setq cope-events (re-time (apply #'multi-generate-forms (first forms)) cope-events))                  (generate-forms :name name :forms (rest forms) :cope-events cope-events)))))#|(RE-TIME '((0 96 6000 12 80) (0 96 6000 12 80) (0 36 6000 12 80) . . . .((0 103 2181 12 113) (2715 100 2016 4 112) . . . .|#(defun RE-TIME (to-be-added-to-events events)  "For placing cope-event groups one after another in time sequence."  (let* ((last-event (my-last events))         (offset-time (if last-event (+ (first last-event)(third last-event)) 0)))    (append events (loop for event in to-be-added-to-events                         collect (cons (+ (first event) offset-time)(rest event))))))#|(EXTEND-FORMS)((0 103 2181 12 113) (2715 100 2016 4 112) . . . .|#(defun EXTEND-FORMS (&optional (name nil)(number 50)(ontimes 'r)(pitches 'r)(durations 'r)(channels 'r)(dynamics 'r)(harmonies nil)(save ()))   "Top-level function for forms for generating MIDI files based on the combination ofd its arguments. Returns the pathname of the MIDI file created."  (if harmonies (let ((cope-events (make-harmonic-cope-events (create-the-numbers number ontimes *low-range-ontimes* *high-range-ontimes* *mod-ontimes* nil)                                                              (create-harmonies number (length (first harmonies)) harmonies)                                                              (create-the-numbers number durations *low-range-durations* *high-range-durations* *mod-durations* nil)                                                              (create-the-numbers number channels *low-range-channels* *high-range-channels* *mod-channels* nil)                                                              (create-the-numbers number dynamics *low-range-dynamics* *high-range-dynamics* *mod-dynamics* nil))))                  (if (not (null name)) (save-as-midi (make-pathname :name name) cope-events nil)                      cope-events))      (let ((cope-events (make-cope-events (create-the-numbers number ontimes *low-range-ontimes* *high-range-ontimes* *mod-ontimes* nil)                                           (create-the-numbers number pitches *low-range-pitch* *high-range-pitch* *mod-pitches*)                                           (create-the-numbers number durations *low-range-durations* *high-range-durations* *mod-durations* nil)                                           (create-the-numbers number channels *low-range-channels* *high-range-channels* *mod-channels* nil)                                           (create-the-numbers number dynamics *low-range-dynamics* *high-range-dynamics* *mod-dynamics* nil))))        (if (and save name) (save-as-midi (make-pathname :name name) cope-events)            cope-events))))#|(MULTI-GENERATE-FORMS)((0 42 2501 3 92) (704 53 864 3 126) (2153 99 2202 16 90) . . . .|#(defun MULTI-GENERATE-FORMS (&optional (name nil)(numbers '(50))(ontimes '(r r))(pitches '(r r))(durations '(r r))(channels '(r r))(dynamics '(r r))(harmonies '(nil nil)))  "Top-level function for generating MIDI files of multi-channel tests, where each channel can be controlled separately according to argument lists."  (multi-gen name numbers ontimes pitches durations channels dynamics harmonies));;;Normalizing.#|(NORMALIZE-NUMBERS '(20 18 15) 36 108)(108 79 36)|#(defun NORMALIZE-NUMBERS (numbers midi-low midi-high)  "Normalizes all of its first argument into the midi range."  (normalize numbers              (apply #'min numbers)             (apply #'max numbers)             midi-low             midi-high))#|(NORMALIZE '(20 18 15) 15 20 36 108)(108 79 36)|#(defun NORMALIZE (numbers data-low data-high midi-low midi-high)  "Normalizes its first argument from its range into the midi range."  (if (null numbers) nil      (cons (normalize-number (first numbers) data-low data-high midi-low midi-high)            (normalize (rest numbers) data-low data-high midi-low midi-high))))                 #|(NORMALIZE-NUMBER 18 15 20 36 108) 79|#(defun NORMALIZE-NUMBER (number data-low data-high midi-low midi-high)  "Normalizes its numerical argument into the midi range."  (round (+ (* (- number data-low)               (/ (- midi-high midi-low)     ;;;note the order here                  (- data-high data-low)))             midi-low)));;;Utilities.#|(CHOOSE-ONE '(1 2 3 4)) 2|#(defun CHOOSE-ONE (list)  "Chooses a random member of its argument."  (nth (random (length list) *rs*)       list))#|(MAKE-COPE-EVENTS '(125 125 125 125 125 . . . .((0 36 904 5 92) (125 108 2436 2 45) (250 44 1634 4 124) . . . .|#(defun MAKE-COPE-EVENTS (ontimes pitches durations channels dynamics &optional (ontime 0))  "Creates contiguous cope-events from its argument lists."  (cond ((any-nullp ontimes pitches durations channels dynamics) nil)        (t (cons (list ontime (first pitches)(first durations)(first  channels)(first dynamics))                 (make-cope-events (rest ontimes)(rest pitches)(rest durations)(rest  channels)(rest dynamics)(+ ontime (first ontimes)))))))#|(ALL-EQUALP '(0 0 0 0 0)) T|#(defun ALL-EQUALP (list-of-numbers &optional (test (first list-of-numbers)))  "Returns if all elements of its argument are the same."  (cond ((equal test (first list-of-numbers)) (all-equalp (rest list-of-numbers) test))        ((null list-of-numbers) t)        (t ())))  #|(MAKE-EQUAL '(1 1 1 1 1) '(2 2 2) '(3 3 3 3 3 3 3) '(4 4 4 4))((1 1 1) (2 2 2) (3 3 3) (4 4 4))|#(defun MAKE-EQUAL (ontimes durations channels dynamics)  "Makes all of its args the length of its shortest one."  (let ((length (find-shortest ontimes durations channels dynamics)))    (list (firstn length ontimes)(firstn length durations)(firstn length channels)(firstn length dynamics))))#|(FIND-SHORTEST '(1 1 1 1 1) '(2 2 2) '(3 3 3 3 3 3 3) '(4 4 4 4)) 3|#(defun FIND-SHORTEST (ontimes durations channels dynamics)  "Returns the shortest of its args."  (apply #'min (list (length ontimes)(length durations)(length channels)(length dynamics))))#|(FIRSTN 3 '(1 1 1 1 1 1 1))(1 1 1)|#(defun FIRSTN (number list)  "Returns the first n number of its list arg."  (if (< (length list) number)(firstn (1- number) list)      (butlast list (- (length list) number))))#|(BROADCAST-THROUGHOUT-RANGE '(0) 500 6000 500)(500 1000 1500 2000 2500 3000 3500 4000 4500 5000 5500 6000)|#(defun BROADCAST-THROUGHOUT-RANGE (list low high octave)  "Broadcasts the set list by using octave between the low and the high."  (if (null list) ()      (append (broadcast (+ (first list) low) high octave)              (broadcast-throughout-range (rest list) low high octave))))#|(BROADCAST 500 6000 500) (500 1000 1500 2000 2500 3000 3500 4000 4500 5000 5500 6000)|#(defun BROADCAST (n high octave)  "Broadcasts n by using octave lower than high."  (if (> n high) ()      (cons n            (broadcast (+ n octave) high octave))))#|(MY-LAST '(1 2 3)) 3|#(defun MY-LAST (list)  "My version of last without the list form."  (first (last list)))#|(UNLIST '(/ 1 (sin (* x x))))(/ 1 SIN * X X)|#(defun UNLIST (lists)  "Places all elements of arbitrary nested lists on the top level."  (cond ((null lists)())        ((listp (first lists))         (unlist (append (first lists)                         (unlist (rest lists)))))        ((atom (first lists))         (cons (first lists)               (unlist (rest lists))))))#|(remove-overlap '((0 50 1000 1 127)(500 50 1000 1 127)))((0 50 500 1 127)(500 50 1000 1 127))|#(defun remove-overlap (cope-events)  (if (null (rest cope-events))    cope-events    (let ((cur-event (first cope-events))          (next-event (second cope-events)))      (if (> (third cur-event)             (- (first next-event)                (first cur-event)))        (cons (list (first cur-event)                    (second cur-event)                    (- (first next-event)                       (first cur-event))                    (fourth cur-event)                    (fifth cur-event))              (remove-overlap (rest cope-events)))        (cons cur-event (remove-overlap (rest cope-events)))))))#|? (ANY-NULLP '(1 2) '(3 4) '() '(5 6))T? (ANY-NULLP '(1 2) '(3 4) '(5 6))NIL|#(defun any-nullp (&rest lists)  "Returns nil if any one of its args is nil."  (if (member nil lists :test #'equal) t nil))#|? (rangep '(52 44))T? (rangep '(0 3))NIL|#(defun rangep (numbers)  "Checks to see if numbers are legal pitches."  (if (and (>= (apply #'min numbers) 24)(<= (apply #'max numbers) 108)) t));;;MIDI-SAVE#|Written by Paul Pelton with additions and changes by Soren Goodman and Dave Cope.The input format that the program uses is one used by David Cope, called "CopeEvents".  Each event is a list in the format (ontime duration pitch channelvolume).  All times are in milliseconds, with pitch as 60 = middle C,channel 1-16, and volume in the range 0-127.  The input should be a list of events in the variable *events*, so for example:((0 60 1500 1 90)(500 64 1000 1 90)(1000 67 500 1 90))would be an arpeggiated major chord (midi pitches 60 64 67) such that the notesenter at different times and will overlap and end at the same time.The format:(save-as-midi (make-pathname :name "dave") '((0 60 1000 1 127)))will put a quarter note middle C in a midi file called "dave" in your top-level disk drive(save-as-midi (make-pathname :directory "books" :name "dave") '((0 60 1000 1 127)))will put the above in a midi file in a folder called "books" in your top-level disk drive and so on.|#(defConstant KMTHDHEADERBYTES '(#x4D #x54 #x68 #x64))(defConstant KMTHDHEADERLENBYTES '(0 0 0 6))(defConstant KMTHDHEADERFORMATBYTES '(0 1))(defConstant KMTRKHEADERBYTES '(#x4D #x54 #x72 #x6B))(defConstant KMTRKENDBYTES '(#x00 #xFF #x2F #x00))(defConstant KPPQNVALUE #x30)(defVar *EVENTS* nil)(defVar *CHANNEL-NO-1* 1)(defVar *CHANNEL-NO-2* 2)(defVar *CHANNEL-NO-3* 3)(defVar *CHANNEL-NO-4* 4)(defVar *CHANNEL-NO-5* 5)(defVar *CHANNEL-NO-6* 6)(defVar *CHANNEL-NO-7* 7)(defVar *CHANNEL-NO-8* 8)(defVar *CHANNEL-NO-9* 9)(defVar *CHANNEL-NO-10* 10)(defVar *CHANNEL-NO-11* 11)(defVar *CHANNEL-NO-12* 12)(defVar *CHANNEL-NO-13* 13)(defVar *CHANNEL-NO-14* 14)(defVar *CHANNEL-NO-15* 15)(defVar *CHANNEL-NO-16* 16)(defvar *overwrite-if-exists* t) #|Calling (SAVE-AS-MIDI #P"mj" ((0 60 1000 1 127))) SAVE-AS-MIDI returned #P"mj"|#(defun SAVE-AS-MIDI (outfilename events &optional (pathname *work-dir*))  (when pathname (setq outfilename (concatenate 'string pathname outfilename)))   (let ((tracks (create-midi-tracks (insert-program-changes events))))      (with-open-stream (file (create-midi-file outfilename))        (push (create-MThd (length tracks)) tracks)        (write-to-midi-file file tracks))     outfilename))    #|Calling (INSERT-PROGRAM-CHANGES ((0 60 1000 1 127))) INSERT-PROGRAM-CHANGES returned ((0 1 0 1 255) (0 2 0 2 255) (0 3 0 3 255) (0 4 0 4 255) (0 5 0 5 255)    (0 6 0 6 255) (0 7 0 7 255) (0 8 0 8 255) (0 9 0 9 255) (0 10 0 10 255) (0 11 0 11 255) (0 12 0 12 255)    (0 13 0 13 255) (0 14 0 14 255) (0 15 0 15 255) (0 16 0 16 255) (0 60 1000 1 127))|#(defun INSERT-PROGRAM-CHANGES (events)  (append   (list    (list 0 *channel-no-1* 0 1 255)    (list 0 *channel-no-2* 0 2 255)    (list 0 *channel-no-3* 0 3 255)    (list 0 *channel-no-4* 0 4 255)    (list 0 *channel-no-5* 0 5 255)    (list 0 *channel-no-6* 0 6 255)    (list 0 *channel-no-7* 0 7 255)    (list 0 *channel-no-8* 0 8 255)    (list 0 *channel-no-9* 0 9 255)    (list 0 *channel-no-10* 0 10 255)    (list 0 *channel-no-11* 0 11 255)    (list 0 *channel-no-12* 0 12 255)    (list 0 *channel-no-13* 0 13 255)    (list 0 *channel-no-14* 0 14 255)    (list 0 *channel-no-15* 0 15 255)    (list 0 *channel-no-16* 0 16 255))   events))   #|Calling (CREATE-MIDI-FILE #P"mj") CREATE-MIDI-FILE returned #<BASIC-FILE-BINARY-OUTPUT-STREAM ("mj"/12 ISO-8859-1) #x8B5E79E>|#(defun CREATE-MIDI-FILE (outfilename)  (open outfilename :direction :output :if-exists (if *overwrite-if-exists* :overwrite :error)        :if-does-not-exist :create :element-type 'unsigned-byte))   #|Calling (WRITE-TO-MIDI-FILE #<BASIC-FILE-BINARY-OUTPUT-STREAM ("mj"/12 ISO-8859-1) #x8B5E79E> ((77 84 104 100 0 0 0 6 0 1 0 17 0 48)     (77 84 114 107 0 0 0 4 0 255 47 0) (77 84 114 107 0 0 0 15 0 192 0 0 144 60 127 48 128 60 127 0 255 47 0)     (77 84 114 107 0 0 0 7 0 193 1 0 255 47 0) (77 84 114 107 0 0 0 7 0 194 2 0 255 47 0) . . . .WRITE-TO-MIDI-FILE returned NIL|#(defun WRITE-TO-MIDI-FILE (file listOfChunks)   (if (null listOfChunks) ()      (progn       (dolist (byte (first listOfChunks))         (write-byte byte file))       (write-to-midi-file file (rest listOfChunks)))))   #|0> Calling (CREATE-MIDI-TRACKS ((0 1 0 1 255) (0 2 0 2 255) (0 3 0 3 255) (0 4 0 4 255) (0 5 0 5 255) (0 6 0 6 255)    (0 7 0 7 255) (0 8 0 8 255) (0 9 0 9 255) (0 10 0 10 255) (0 11 0 11 255) (0 12 0 12 255) (0 13 0 13 255) (0 14 0 14 255)    (0 15 0 15 255) (0 16 0 16 255) (0 60 1000 1 127))) CREATE-MIDI-TRACKS returned ((77 84 114 107 0 0 0 4 0 255 47 0) (77 84 114 107 0 0 0 15 0 192 0 0 144 60 127 48 128 60 127 0 255 47 0)    (77 84 114 107 0 0 0 7 0 193 1 0 255 47 0) (77 84 114 107 0 0 0 7 0 194 2 0 255 47 0) (77 84 114 107 0 0 0 7 0 195 3 0 255 47 0) . . . |#(defun CREATE-MIDI-TRACKS (copeEvents)  (let ((tracks (create-tempo-track)))    (dotimes (channel 16 (reverse tracks))      (let ((channelEvents (get-channel-events (1+ channel) copeEvents)))        (if channelEvents          (push (create-MTrk channelEvents) tracks))))))   #|Calling (CREATE-TEMPO-TRACK) CREATE-TEMPO-TRACK returned ((77 84 114 107 0 0 0 4 0 255 47 0))|#(defun CREATE-TEMPO-TRACK ()   (list (append kMTrkHeaderBytes (split-bytes (length kMTrkEndBytes) 4) kMTrkEndBytes)))   #|Calling (GET-CHANNEL-EVENTS 1 ((0 1 0 1 255) (0 2 0 2 255) (0 3 0 3 255) (0 4 0 4 255) (0 5 0 5 255) (0 6 0 6 255)     (0 7 0 7 255) (0 8 0 8 255) (0 9 0 9 255) (0 10 0 10 255) (0 11 0 11 255) (0 12 0 12 255) (0 13 0 13 255) (0 14 0 14 255)     (0 15 0 15 255) (0 16 0 16 255) (0 60 1000 1 127))) GET-CHANNEL-EVENTS returned ((0 1 0 1 255) (0 60 1000 1 127))|#(defun GET-CHANNEL-EVENTS (channel events)   (cond    ((null events) ())    ((= channel (fourth (first events)))     (cons (first events) (get-channel-events channel (rest events))))    (t (get-channel-events channel (rest events)))))   #|Calling (MAKE-VAR-LEN 0) MAKE-VAR-LEN returned (0)this is adapted to Lisp from the C code atwww.borg.com/~jglatt/tech/midifile.htm|#(defun MAKE-VAR-LEN (value)   (let ((buffer (list (logand #x7F value))))      (loop while (not (zerop (setq value (ash value -7))))         do (push (logior (logior #x80 (logand #x7F value))) buffer))      buffer))   #|Calling (CREATE-MTHD 17) CREATE-MTHD returned (77 84 104 100 0 0 0 6 0 1 0 17 0 48)assume that 1 <= numtracks <= 16|#(defun CREATE-MTHD (numtracks)   (append    kMThdHeaderBytes    kMThdHeaderLenBytes    kMThdHeaderFormatBytes    (list 0 numtracks 0 kPPQNValue)))   #|Calling (CREATE-MTRK ((0 1 0 1 255) (0 60 1000 1 127))) CREATE-MTRK returned (77 84 114 107 0 0 0 15 0 192 0 0 144 60 127 48 128 60 127 0 255 47 0)assume 2 bytes for length of track data|#(defun CREATE-MTRK (events)   (if (null events) ()      (let* ((mtrkData              (append               (create-midi-track-data                (fix-deltatime 0 (sort-by-deltatime (create-midi-events events))))               kMTrkEndBytes)))         (append kMTrkHeaderBytes (split-bytes (length mtrkData) 4) mtrkData))))   #| Calling (SPLIT-BYTES 7 4) SPLIT-BYTES returned (0 0 0 7)splits a long integer into its high byte and low byte|#(defun SPLIT-BYTES (num count)   (let ((bytes ()))      (dotimes (i count bytes)         (push (get-byte i num) bytes))))   #|Calling (GET-BYTE 3 7) GET-BYTE returned 0byteIndex starts at 0 (rightmost) and goes to whatever (leftmost)|#(defun GET-BYTE (byteIndex num)   (ldb (byte 8 (* 8 byteIndex)) num))   #|Calling (CREATE-MIDI-TRACK-DATA ((0 (193 1)))) CREATE-MIDI-TRACK-DATA returned (0 193 1)midiEvents are ((deltaTime (byte3 byte2 byte1))(deltaTime (byte3 byte2 byte1))...),are sorted in the order they should be in the file and their deltaTimes arerelative to each other (each relative to the previous).|#(defun CREATE-MIDI-TRACK-DATA (midiEvents)   (if (null midiEvents) ()      (let ((midiEvt (first midiEvents)))        (append         (make-var-len (first midiEvt))         (second midiEvt)         (create-midi-track-data (rest midiEvents))))))   #|Calling (CREATE-MIDI-EVENTS ((0 3 0 3 255))) CREATE-MIDI-EVENTS returned ((0 (194 2)))|#(defun CREATE-MIDI-EVENTS (copeEvents)   (if (null copeEvents) ()      (let* ((event (first copeEvents))             (ontime (first event)))         (append          (cond ((= (fifth event) 255)                 (list (list (convert-ontime-to-deltatime ontime) (make-midi-pc-msg event))))                (t                 (list                  (list                   (convert-ontime-to-deltatime ontime) (make-midi-note-msg event #x90))                  (list                   (convert-ontime-to-deltatime (+ ontime (third event))) (make-midi-note-msg event #x80)))))          (create-midi-events (rest copeEvents))))))   #|Calling (MAKE-MIDI-NOTE-MSG (0 60 1000 1 127) 144) MAKE-MIDI-NOTE-MSG returned (144 60 127)#x90 = note-on#x80 = note-off|#(defun MAKE-MIDI-NOTE-MSG (copeEvent flag)   (list (logior (1- (fourth copeEvent)) flag) (second copeEvent) (fifth copeEvent)))   #|Calling (MAKE-MIDI-PC-MSG (0 16 0 16 255)) MAKE-MIDI-PC-MSG returned (207 15)#xC0 = program change|#(defun MAKE-MIDI-PC-MSG (copeEvent)   (list (logior (1- (fourth copeEvent)) #xC0) (1- (second copeEvent))))                 #|Calling (SORT-BY-DELTATIME ((0 (207 15)))) SORT-BY-DELTATIME returned ((0 (207 15)))|#                                 (defun SORT-BY-DELTATIME (midiEvents)   (sort midiEvents #'< :key #'car))   #|Calling (FIX-DELTATIME 0 ((0 (207 15)))) FIX-DELTATIME returned ((0 (207 15)))|#(defun FIX-DELTATIME (lasttime midiEvents)   (if (null midiEvents) ()      (let* ((midiEvt (first midiEvents))            (newLastTime (first midiEvt)))         (cons          (list (- newLastTime lasttime) (second midiEvt))          (fix-deltatime newLastTime (rest midiEvents))))))   #|Calling (CONVERT-ONTIME-TO-DELTATIME 0) CONVERT-ONTIME-TO-DELTATIME returned 2 values :      0      0|#(defun CONVERT-ONTIME-TO-DELTATIME (copeOntime)   (round (* (/ kPPQNValue 1000) copeOnTime)));;;MIDI-LOAD;; This is the simple version.;; All it gives is a list of note events;; Tempo events are collected and used to calculate times;; Text Meta events are colleccted into *sequence-strings*;; other events are discarded;; the functiion load-midifile requires a valid path as a string.;; this version uses special variables, a forthcoming version will be self contained.;; pqe 6-04-08(defVar *CHUNK-TYPE* ())             ; only two types are defined so far(defVar *CHUNK-LENGTH* 0)            ; number of bytes in chunk(defVar *MIDI-FILE-FORMAT* 0)        ; type 0 is single track, type 1 is multitrack, type 2 is indepentent loops(defVar *MIDI-FILE-NTRKS* 0)         ; number of tracks in file(defVar *MIDI-FILE-GRANULARITY* 24)  ; number of ticks per quarter note(defVar *TRACK-TIME* 0)              ; unconverted track time, in ticks(defVar *RUNNING-STATUS* 0)          ; running status is used(defVar *TRACK-END* t)               ; flag for finding ends of tracks (rather than byte coounting) EOT sets this nil;; A place to put metadata -- later version can be more elegant(defVar *SEQUENCE-STRINGS* (make-array 1 :initial-contents #("sequence-strings") :fill-pointer t :adjustable t ));; a place to put tempos. all tracks must refer to this when converting from ticks to time in ms;; format of each entry is (time-in-ticks time-in-ms usec/qn)(defVar *SEQUENCE-TEMPO-MAP* (make-array 1 :element-type 'list :initial-element '(0 0 500000) :fill-pointer t :adjustable t ));; a place to put note data;; *sequence-notes* format is (time-ms  note-number duration channel velocity);; This is an array to simplify setting durations when note off is detected.(defVar *SEQUENCE-NOTES* (make-array 0 :element-type 'list :initial-element '(0 0 0 0 0) :fill-pointer t :adjustable t )); helper for header reading(defun GET-TYPE (input-stream)    (let ((type-string (make-string 4)))      (loop for i from 0 to 3            do (setf (char type-string i) (code-char(read-byte input-stream)))            )      type-string)); general 32 bit retreiver(defun GET-WORD (input-stream)    (let ((value 0))      (loop for i from 0 to 3            do (setq value (+ (* value 256) (read-byte input-stream)))            )      value)); general 16 bit retriever(defun GET-SHORT (input-stream)    (+ (* (read-byte input-stream) 256) (read-byte input-stream))); division is weird- this is a try at making sense out of it; granularity is ticks per beat (quarter note)(defun CONVERT-GRANULARITY (division)  (let ((high-byte (ash division -8))(low-byte (logand #XFF)))    (case high-byte      (#XE2 (* 30 low-byte))      (#XE3 (* 30 low-byte))      (#XE7 (* 25 low-byte))      (#XE8 (* 24 low-byte))      (t division)))); read the file header(defun GET-HEADER (input-stream)    (setq *chunk-type* (get-type input-stream))    (setq *chunk-length* (get-word input-stream))    (setq *midi-file-format* (get-short input-stream))    (setq *midi-file-ntrks* (get-short input-stream))    (setq *midi-file-granularity*(convert-granularity (get-short input-stream)))); read a track header(defun GET-TRACK-HEADER (input-stream)    (setq *chunk-type* (get-type input-stream))    (setq *chunk-length* (get-word input-stream))); time is listed as ticks in variable length quantities(defun CONVERT-VLQ (arg-list &optional (accum 0))      (if (> (first arg-list) 127)        (convert-vlq (rest arg-list) (+ (- (first arg-list) 128) (* accum 128)))        (+ (first arg-list) (* accum 128)))); all events are seperated by a delta time (defun GET-VLQ (input-stream)  (let ((new-byte (read-byte input-stream)))    (if (< new-byte 128) (list new-byte)        (cons new-byte (get-vlq input-stream))))); times are between events, so *track-time* must be accumulated across each track(defun SET-TRACK-TIME (input-stream)  (incf *track-time* (convert-vlq (get-vlq input-stream)))); read arbitrary bytes into a list(defun GATHER-BYTES (input-stream how-many)  (if (zerop how-many) ()      (cons (read-byte input-stream) (gather-bytes input-stream (1- how-many))))); reads a length, then gathers that many(defun GET-METADATA (input-stream)  (gather-bytes input-stream (read-byte input-stream))); test function for tempo searches(defun FIRST>= ( data alist)  (>= data (first alist) ));; Stuff the tempo map. format of each entry is (time-in-ticks time-in-ms usec/qn);; tempo and granualrity are need to convert ticks to ms;; storing the time of the tempo change in both formats simplifies the calculations(defun ADD-TEMPO (the-data)  (let* ((us-qn (+ (ash (first the-data) 16)(ash (second the-data) 8) (third the-data)))	(last-tempo-entry (elt *sequence-tempo-map*  (- (length *sequence-tempo-map* )1)))        (last-tempo-time (second last-tempo-entry))        (last-tempo (third last-tempo-entry))        (ticks (- *track-time* (first last-tempo-entry))))    (vector-push-extend (list *track-time* 			      (+ last-tempo-time                                 (/(* ticks last-tempo )(* *midi-file-granularity* 1000)))                                 us-qn)                        *sequence-tempo-map*)));; the time conversion function;; search the tempo map from the end to find tempo in effect at the time(defun TICKS-MS (ticks)  (let* ((current-tempo-entry (find ticks *sequence-tempo-map* :test #'first>= :from-end t))	 (current-tempo-time (second current-tempo-entry))	 (current-tempo (third current-tempo-entry))	 (delta-ticks (- ticks (first current-tempo-entry))))    (float (+ current-tempo-time (/(* delta-ticks current-tempo)(* *midi-file-granularity* 1000))))));; most meta-data is text(defun LIST-TO-STRING (ascii)  (if (null ascii) #\.       (format nil "~A~A" (code-char (car ascii)) (list-to-string (cdr ascii)))));; meta data is mostly in the way, but tempos and end of trak are vital(defun PARSE-METADATA (the-data)  (case (car the-data)    (0 ()) ; sequence number    ((1 2 3 4 5 6 7 8 9 10)  (vector-push-extend (list-to-string (cdr the-data)) *sequence-strings* )); text     (#X20 ()) ; MIDI Channel prefix    (#X2F (setq *track-end* nil)) ; End of track    (#X51 (add-tempo (cdr the-data))) ; Set tempo  usec/qn in *sequence-tempo-map*    (#X54 ()) ;  SMPTE offset H:M:S:F:F/100    (#X58 ()) ;  Time Signature nnn dd  cc bb    (#X59 ()) ;  Key Signature    (#X7F ()) ;  Program specific    (t ())))  ; unknown;; Other events to parse;; note ons are keepers(defun HANDLE-NOTE (status nn vel)  (vector-push-extend (list (ticks-ms *track-time*) nn 0 (+ (logand status #X0F) 1) vel ) *sequence-notes* )); test function for not off, which must search for matching note on(defun MATCH-NOTE (status-nn target)  (and (= (second status-nn) (second target))(= (first status-nn) (fourth target))(zerop (third target))));; search for note on this belongs to and set duration;; this doesn't handle overlapping notes of the same pitch well but whatcha gonna do?;; note number is &rest because we don't get a velocity with running status;; note off velocity is discarded anyhow(defun HANDLE-OFF (status &rest nn  )  (let* ((channel (+ (logand status #X0F) 1)) 	 (where (position (list channel (first nn)) *sequence-notes* :test #'match-note :from-end t))	 (the-note)	 (duration))    (if (null where) () ; no matchng note on      (progn	(setf the-note (elt *sequence-notes* where))	(setf duration (- (ticks-ms *track-time*) (first the-note)))	(setf (third (elt *sequence-notes* where)) duration)))));; these just discard the data- ther are listed to prevent compiler warnings;; one day I'll do something intelligent with these(defun HANDLE-TOUCH (status nn pressure)  (list status nn pressure))(defun HANDLE-CONTROL (status cn value)  (list status cn value))(defun HANDLE-PROGRAM (status pn)  (list status pn))(defun HANDLE-PRESSURE (status pressure)  (list status pressure))(defun HANDLE-BEND (status lsb msb)  (list status lsb msb))(defun STRIP-SYSEX (input-stream)  "just delete sysex for now"  (if (= (read-byte input-stream) #XF7) ()      (strip-sysex input-stream)));;; this is the grand track data handler(defun PARSE-EVENTS (status-byte data-byte input-stream)  (let ((vel))   (cond     ((< status-byte #X90) (handle-off status-byte data-byte (read-byte input-stream)))    ((< status-byte #XA0) (if (zerop (setq vel (read-byte input-stream)))                             (handle-off status-byte data-byte )                                (handle-note status-byte data-byte vel)))    ((< status-byte #XB0) (handle-touch status-byte data-byte (read-byte input-stream)))    ((< status-byte #XC0) (handle-control status-byte data-byte (read-byte input-stream)))    ((< status-byte #XD0) (handle-program status-byte data-byte ))    ((< status-byte #XE0) (handle-pressure status-byte data-byte ))    ((< status-byte #XF0) (handle-bend status-byte data-byte (read-byte input-stream)))    ((= status-byte #XF0) (strip-sysex input-stream))    ((= status-byte #XFF) (parse-metadata (cons data-byte (get-metadata input-stream))))    (t ()))));;; this layer deals with running status(defun READ-AND-PARSE-EVENT (input-stream)  (let ((first-byte (read-byte input-stream)))    (if (>= first-byte #X80) (parse-events (setf *running-status* first-byte) (read-byte input-stream) input-stream)      (parse-events *running-status* first-byte input-stream))));;;; call this once per track(defun READ-TRACK (input-stream)  (get-track-header input-stream)  (if (zerop *chunk-length*) ()    (if (not (equal *chunk-type* "MTrk")) (gather-bytes input-stream *chunk-length*) ; discard alien chunks      (do ((*track-end* t)(*track-time* 0)(*running-status* 0))	  ((null *track-end*)())	(set-track-time input-stream)	(read-and-parse-event input-stream)))));;;; initialize all those specials(defun SETUP ()  (setf *sequence-strings* (make-array 1 :initial-contents #("sequence-strings") :fill-pointer t :adjustable t ))  (setq *sequence-tempo-map* (make-array 1 :element-type 'list :initial-element '(0 0 500000) :fill-pointer t :adjustable t ))  (setq *sequence-notes* (make-array 0 :element-type 'list :initial-element '(0 0 0 0 0) :fill-pointer t :adjustable t ))) ;; test function for sorting by time(defun EARLIER (alist blist)  (< (first alist) (first blist)));;;;;;;; Ta-Da ;;;;;;;;;;;;;;;(defun LOAD-MIDI-FILE (fstring)  (with-open-file (input-stream fstring :element-type '(unsigned-byte 8) :if-does-not-exist nil)    (setup)    (get-header input-stream)    (do ((track-index 0 (+ track-index 1)))	((>= track-index *midi-file-ntrks*) ())      (read-track input-stream))   (setq *sequence-notes* (sort *sequence-notes* #'earlier))    (loop for notes across *sequence-notes* collect (mapcar #'round notes)))); test with a short file; this is the path format for mac; if you put your stuff directly in documents, your path may be; "/Users/WACM/Documents/myfile.mid"; (load-midi-file "/Users/peterelsea/Documents/lispWork/arp2.mid")(defun RE-TIME (to-be-added-to-events events)  "For placing cope-event groups one after another in time sequence."  (let* ((last-event (my-last events))         (offset-time (if last-event (+ (first last-event)(third last-event)) 0)))    (append events (loop for event in to-be-added-to-events                         collect (cons (+ (first event) offset-time)(rest event))))))